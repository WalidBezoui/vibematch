import {\n  assertFails,\n  assertSucceeds,\n  initializeTestEnvironment,\n  type RulesTestEnvironment,\n} from '@firebase/rules-unit-testing';\nimport { setDoc, doc, getDoc, deleteDoc, updateDoc, collection, query, where, getDocs } from 'firebase/firestore';\nimport { readFileSync } from 'fs';\nimport { describe, it, beforeAll, afterAll, beforeEach, assert } from 'vitest';\n\nlet testEnv: RulesTestEnvironment;\n\nconst brandId = 'brand-user';\nconst creatorId = 'creator-user';\nconst anotherCreatorId = 'another-creator';\nconst intruderId = 'intruder';\n\ndescribe('Firestore Security Rules', () => {\n  beforeAll(async () => {\n    testEnv = await initializeTestEnvironment({\n      projectId: 'studio-6015308119-5a7a7',\n      firestore: {\n        rules: readFileSync('firestore.rules', 'utf8'),\n        host: 'localhost',\n        port: 8080,\n      },\n    });\n  });\n\n  afterAll(async () => {\n    await testEnv.cleanup();\n  });\n\n  beforeEach(async () => {\n    await testEnv.clearFirestore();\n    // Setup initial user roles and brand profile\n    await testEnv.withSecurityRulesDisabled(async (context) => {\n      const firestore = context.firestore();\n      await setDoc(doc(firestore, `users/${brandId}`), { uid: brandId, role: 'brand' });\n      await setDoc(doc(firestore, `users/${creatorId}`), { uid: creatorId, role: 'creator' });\n      await setDoc(doc(firestore, `users/${anotherCreatorId}`), { uid: anotherCreatorId, role: 'creator' });\n      // Also create a brand document for the exists() check in campaign rules\n      await setDoc(doc(firestore, `brands/${brandId}`), { uid: brandId, name: 'Test Brand' });\n    });\n  });\n  \n  describe('User Profile Rules', () => {\n    it('should ALLOW a user to create their own profile', async () => {\n      const newUser = 'new-user-id';\n      const db = testEnv.authenticatedContext(newUser).firestore();\n      await assertSucceeds(setDoc(doc(db, `users/${newUser}`), { uid: newUser, role: 'creator' }));\n    });\n    \n    it('should DENY a user from creating a profile for someone else', async () => {\n        const newUser = 'new-user-id';\n        const db = testEnv.authenticatedContext(newUser).firestore();\n        await assertFails(setDoc(doc(db, `users/another-user`), { uid: 'another-user', role: 'creator' }));\n    });\n\n    it('should ALLOW a user to update their own profile', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertSucceeds(updateDoc(doc(db, `users/${creatorId}`), { displayName: 'New Name' }));\n    });\n    \n    it('should DENY a user from updating someone else\\\'s profile', async () => {\n        const db = testEnv.authenticatedContext(intruderId).firestore();\n        await assertFails(updateDoc(doc(db, `users/${creatorId}`), { displayName: 'Hacked' }));\n    });\n    \n    it('should DENY a creator from updating admin-only fields on their profile', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertFails(updateDoc(doc(db, `users/${creatorId}`), { adminBadge: true }));\n        await assertFails(updateDoc(doc(db, `users/${creatorId}`), { initialTrustScore: 100 }));\n    });\n  });\n\n  describe('Campaign Rules', () => {\n    const campaignId = 'campaign-123';\n    \n    beforeEach(async () => {\n        await testEnv.withSecurityRulesDisabled(async (context) => {\n            const firestore = context.firestore();\n            await setDoc(doc(firestore, `campaigns/${campaignId}`), { brand_id: brandId, title: 'Test Campaign' });\n        });\n    });\n\n    it('should ALLOW a brand to create a campaign with their own brandId', async () => {\n      const db = testEnv.authenticatedContext(brandId).firestore();\n      await assertSucceeds(setDoc(doc(db, 'campaigns/new-campaign'), { brand_id: brandId, title: 'Brand New Campaign' }));\n    });\n\n    it('should DENY a creator from creating a campaign', async () => {\n      const db = testEnv.authenticatedContext(creatorId).firestore();\n      await assertFails(setDoc(doc(db, 'campaigns/creator-campaign'), { brand_id: creatorId, title: 'Creator Campaign' }));\n    });\n    \n    it('should ALLOW a creator to read any campaign', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertSucceeds(getDoc(doc(db, `campaigns/${campaignId}`)));\n    });\n    \n    it('should ALLOW a brand to read their OWN campaign', async () => {\n        const db = testEnv.authenticatedContext(brandId).firestore();\n        await assertSucceeds(getDoc(doc(db, `campaigns/${campaignId}`)));\n    });\n\n    it('should ALLOW a brand to read another brand\\\'s campaign', async () => {\n        const otherBrandId = 'other-brand';\n        const db = testEnv.authenticatedContext(otherBrandId).firestore();\n        await assertSucceeds(getDoc(doc(db, `campaigns/${campaignId}`)));\n    });\n\n    it('should ALLOW a brand to delete their own campaign', async () => {\n        const db = testEnv.authenticatedContext(brandId).firestore();\n        await assertSucceeds(deleteDoc(doc(db, `campaigns/${campaignId}`)));\n    });\n\n    it('should DENY a creator from deleting a campaign', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertFails(deleteDoc(doc(db, `campaigns/${campaignId}`)));\n    });\n  });\n\n  describe('Campaign Application Rules', () => {\n    const campaignId = 'application-campaign';\n    const applicationId = 'app-123';\n\n    beforeEach(async () => {\n        await testEnv.withSecurityRulesDisabled(async (context) => {\n            const firestore = context.firestore();\n            await setDoc(doc(firestore, `campaigns/${campaignId}`), { brand_id: brandId, title: 'Application Campaign' }); // Added brand_id\n            await setDoc(doc(firestore, `campaign-applications/${applicationId}`), { creator_id: creatorId, campaignId: campaignId }); // Changed path and added campaignId\n        });\n    });\n\n    it('should ALLOW a creator to create an application for themselves', async () => {\n        const db = testEnv.authenticatedContext(anotherCreatorId).firestore();\n        await assertSucceeds(setDoc(doc(db, `campaign-applications/new-app`), { creator_id: anotherCreatorId, campaignId: campaignId }));\n    });\n\n    it('should DENY a creator from creating an application for someone else', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertFails(setDoc(doc(db, `campaign-applications/fraud-app`), { creator_id: intruderId, campaignId: campaignId }));\n    });\n    \n    it('should ALLOW the brand owner to read an application', async () => {\n        const db = testEnv.authenticatedContext(brandId).firestore();\n        await assertSucceeds(getDoc(doc(db, `campaign-applications/${applicationId}`)));\n    });\n    \n    it('should ALLOW the creator who applied to read their application', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertSucceeds(getDoc(doc(db, `campaign-applications/${applicationId}`)));\n    });\n\n    it('should DENY another creator from reading an application', async () => {\n        const db = testEnv.authenticatedContext(anotherCreatorId).firestore();\n        await assertFails(getDoc(doc(db, `campaign-applications/${applicationId}`)));\n    });\n    \n    it('should ALLOW the creator to delete their own application', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        await assertSucceeds(deleteDoc(doc(db, `campaign-applications/${applicationId}`)));\n    });\n  });\n\n  describe('Chat Message Rules', () => {\n    const conversationId = 'conversation-123';\n\n    beforeEach(async () => {\n      await testEnv.withSecurityRulesDisabled(async (context) => {\n        await setDoc(doc(context.firestore(), `conversations/${conversationId}`), {\n          brand_id: brandId,\n          creator_id: creatorId,\n          campaign_id: 'some-campaign',\n          application_id: 'some-application',\n        });\n      });\n    });\n\n    it('should ALLOW a participant to send a secure message', async () => {\n      const db = testEnv.authenticatedContext(brandId).firestore();\n      await assertSucceeds(setDoc(doc(db, `conversations/${conversationId}/messages/msg1`), { sender_id: brandId, text: 'This is a perfectly safe message.', timestamp: new Date() }));\n    });\n\n    it('should DENY a non-participant from sending a message', async () => {\n      const db = testEnv.authenticatedContext(intruderId).firestore();\n      await assertFails(setDoc(doc(db, `conversations/${conversationId}/messages/msg5`), { sender_id: intruderId, text: 'I am an intruder.', timestamp: new Date() }));\n    });\n\n    it('should DENY any user from updating or deleting a message', async () => {\n        const messageId = 'msg-to-delete';\n        await testEnv.withSecurityRulesDisabled(async (context) => {\n            await setDoc(doc(context.firestore(), `conversations/${conversationId}/messages/${messageId}`), { sender_id: creatorId, text: 'original', timestamp: new Date() });\n        });\n\n        const brandDb = testEnv.authenticatedContext(brandId).firestore();\n        const creatorDb = testEnv.authenticatedContext(creatorId).firestore();\n        \n        await assertFails(updateDoc(doc(brandDb, `conversations/${conversationId}/messages/${messageId}`), { text: 'edited' }));\n        await assertFails(deleteDoc(doc(creatorDb, `conversations/${conversationId}/messages/${messageId}`)));\n    });\n  });\n\n  describe('Conversation List Rules', () => {\n    const campaignId = 'campaign-for-conversations';\n\n    beforeEach(async () => {\n        await testEnv.withSecurityRulesDisabled(async (context) => {\n            const firestore = context.firestore();\n            await setDoc(doc(firestore, `campaigns/${campaignId}`), { brand_id: brandId });\n            await setDoc(doc(firestore, 'conversations/convo1'), { campaign_id: campaignId, brand_id: brandId, creator_id: creatorId });\n            await setDoc(doc(firestore, 'conversations/convo2'), { campaign_id: campaignId, brand_id: brandId, creator_id: anotherCreatorId });\n            await setDoc(doc(firestore, 'conversations/convo3'), { campaign_id: 'another-campaign', brand_id: 'another-brand', creator_id: creatorId });\n        });\n    });\n\n    it('should ALLOW a brand to list conversations for a campaign they own', async () => {\n        const db = testEnv.authenticatedContext(brandId).firestore();\n        const q = query(collection(db, 'conversations'), where('campaign_id', '==', campaignId), where('brand_id', '==', brandId));\n        await assertSucceeds(getDocs(q));\n    });\n\n    it('should ALLOW a creator to list conversations for a campaign they are part of', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        const q = query(collection(db, 'conversations'), where('campaign_id', '==', campaignId), where('creator_id', '==', creatorId));\n        await assertSucceeds(getDocs(q));\n    });\n\n    it('should DENY listing conversations with only campaign_id filter for a user who is not part of all conversations', async () => {\n        const db = testEnv.authenticatedContext(creatorId).firestore();\n        // This query attempts to get all conversations for the campaign, but the rules require\n        // that the user is a participant in every document returned by the list query.\n        // Since convo2 has a different creator, this should fail.\n        const q = query(collection(db, 'conversations'), where('campaign_id', '==', campaignId));\n        await assertFails(getDocs(q));\n    });\n\n    it('should DENY an unauthenticated user from listing conversations', async () => {\n        const db = testEnv.unauthenticatedContext().firestore();\n        const q = query(collection(db, 'conversations'), where('campaign_id', '==', campaignId));\n        await assertFails(getDocs(q));\n    });\n\n    it('should DENY an uninvolved user from listing conversations', async () => {\n        const db = testEnv.authenticatedContext(intruderId).firestore();\n        const q = query(collection(db, 'conversations'), where('campaign_id', '==', campaignId), where('creator_id', '==', intruderId));\n        // This should succeed with an empty result if the rules were just checking the query, \n        // but since the list operation is denied at a broader level if no documents could ever be returned,\n        // it's better to test the principle. A query for conversations they are not part of should not return anything.\n        // Let's assert that the query for documents they *could* be part of returns nothing and succeeds.\n        const result = await getDocs(q);\n        assert.equal(result.size, 0);\n    });\n  });\n});\n